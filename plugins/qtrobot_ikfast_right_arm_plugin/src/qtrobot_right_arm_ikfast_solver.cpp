/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2020-04-17 14:35:11.614296
/// Generated using solver translation3d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=((0.07708)*x1);
x3=IKcos(j[2]);
x4=((0.184)*x1*x3);
x5=IKsin(j[2]);
x6=IKcos(j[1]);
x7=((0.184)*x5*x6);
x8=IKsin(j[0]);
IkReal x9=((1.0)*x0);
eetrans[0]=((((-1.0)*x2*x9))+(((-1.0)*x4*x9))+(((-1.0)*x7*x9)));
eetrans[1]=((-0.1245)+(((-1.0)*(0.07708)*x6))+(((0.184)*x1*x5))+(((-1.0)*(0.184)*x3*x6)));
IkReal x10=((1.0)*x8);
eetrans[2]=((0.396)+(((-1.0)*x10*x2))+(((-1.0)*x10*x4))+(((-1.0)*x10*x7)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 3; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j7,cj7,sj7,htj7,j7mul,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij5[2], _nj5,_ij6[2], _nj6,_ij7[2], _nj7;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; j7=numeric_limits<IkReal>::quiet_NaN(); _ij7[0] = -1; _ij7[1] = -1; _nj7 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((-0.396)+pz);
new_pz=((-0.1245)+(((-1.0)*(1.0)*py)));
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j7array[2], cj7array[2], sj7array[2];
bool j7valid[2]={false};
_nj7 = 2;
cj7array[0]=((-1.40302164887976)+(((35.2541684528779)*(px*px)))+(((35.2541684528779)*(py*py)))+(((35.2541684528779)*(pz*pz))));
if( cj7array[0] >= -1-IKFAST_SINCOS_THRESH && cj7array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j7valid[0] = j7valid[1] = true;
    j7array[0] = IKacos(cj7array[0]);
    sj7array[0] = IKsin(j7array[0]);
    cj7array[1] = cj7array[0];
    j7array[1] = -j7array[0];
    sj7array[1] = -sj7array[0];
}
else if( isnan(cj7array[0]) )
{
    // probably any value will work
    j7valid[0] = true;
    cj7array[0] = 1; sj7array[0] = 0; j7array[0] = 0;
}
for(int ij7 = 0; ij7 < 2; ++ij7)
{
if( !j7valid[ij7] )
{
    continue;
}
_ij7[0] = ij7; _ij7[1] = -1;
for(int iij7 = ij7+1; iij7 < 2; ++iij7)
{
if( j7valid[iij7] && IKabs(cj7array[ij7]-cj7array[iij7]) < IKFAST_SOLUTION_THRESH && IKabs(sj7array[ij7]-sj7array[iij7]) < IKFAST_SOLUTION_THRESH )
{
    j7valid[iij7]=false; _ij7[1] = iij7; break; 
}
}
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

{
IkReal j5eval[1];
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=((((5.43478260869565)*(IKabs(((0.07708)+(((0.184)*cj7)))))))+(IKabs(sj7)));
j6eval[1]=((1.0)+(((5.69839085090494)*(cj7*cj7)))+(((5.69839085090494)*(sj7*sj7)))+(((4.77426050856253)*cj7)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
px=0;
py=0;
pp=pz*pz;
j6eval[0]=pz;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
px=0;
py=0;
pp=pz*pz;
j6eval[0]=pz;
j6eval[1]=(pz+(((2.38713025428127)*cj7*pz)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((0.418913043478261)+cj7)))+(IKabs(((-1.0)+(IKsign(sj7)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
px=0;
py=0;
pp=pz*pz;
sj7=0.90802635550129;
cj7=-0.418913044229572;
j7=2.00304426673747;
j6eval[0]=pz;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
j6array[0]=3.14159265276238;
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=6.28318530635218;
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((1.38241304595759e-10)*(IKsin(j6))))+(((-1.0)*(0.167076849412237)*(IKcos(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x12=IKPowWithIntegerCheck(pz,-1);
if(!x12.valid){
continue;
}
IkReal x11=x12.value;
if( IKabs(((-0.167076849412237)*x11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.38241304595759e-10)*x11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.167076849412237)*x11))+IKsqr(((-1.38241304595759e-10)*x11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-0.167076849412237)*x11), ((-1.38241304595759e-10)*x11));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x13=IKcos(j6);
IkReal x14=((1.0)*pz);
IkReal x15=IKsin(j6);
evalcond[0]=((-1.38241304595759e-10)+(((-1.0)*x13*x14)));
evalcond[1]=((-0.167076849412237)+(((-1.0)*x14*x15)));
evalcond[2]=((((1.38241304595759e-10)*x15))+(((-0.167076849412237)*x13)));
evalcond[3]=((0.0279146736)+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x13)));
evalcond[4]=((((-1.0)*x14))+(((-1.38241304595759e-10)*x13))+(((-0.167076849412237)*x15)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj7)))))+(IKabs(((0.418913043478261)+cj7)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
px=0;
py=0;
pp=pz*pz;
sj7=-0.90802635550129;
cj7=-0.418913044229572;
j7=-2.00304426673747;
j6eval[0]=pz;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
j6array[0]=8.27411488079171e-10;
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=3.1415926544172;
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[1];
evalcond[0]=((((1.38241304595759e-10)*(IKsin(j6))))+(((0.167076849412237)*(IKcos(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x17=IKPowWithIntegerCheck(pz,-1);
if(!x17.valid){
continue;
}
IkReal x16=x17.value;
if( IKabs(((0.167076849412237)*x16)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.38241304595759e-10)*x16)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.167076849412237)*x16))+IKsqr(((-1.38241304595759e-10)*x16))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((0.167076849412237)*x16), ((-1.38241304595759e-10)*x16));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x18=IKcos(j6);
IkReal x19=((1.0)*pz);
IkReal x20=IKsin(j6);
evalcond[0]=((-1.38241304595759e-10)+(((-1.0)*x18*x19)));
evalcond[1]=((0.167076849412237)+(((-1.0)*x19*x20)));
evalcond[2]=((((1.38241304595759e-10)*x20))+(((0.167076849412237)*x18)));
evalcond[3]=((0.0279146736)+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x18)));
evalcond[4]=((((-1.0)*x19))+(((0.167076849412237)*x20))+(((-1.38241304595759e-10)*x18)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
px=0;
py=0;
pp=0;
pz=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j5, j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x21=IKPowWithIntegerCheck(pz,-1);
if(!x21.valid){
continue;
}
CheckValue<IkReal> x22=IKPowWithIntegerCheck(((((0.07708)*pz))+(((0.184)*cj7*pz))),-1);
if(!x22.valid){
continue;
}
if( IKabs(((-1.0)*(((0.184)*sj7*(x21.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x22.value)*(((-0.033856)+(pz*pz)+(((0.033856)*(cj7*cj7))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((0.184)*sj7*(x21.value)))))+IKsqr(((x22.value)*(((-0.033856)+(pz*pz)+(((0.033856)*(cj7*cj7)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((0.184)*sj7*(x21.value)))), ((x22.value)*(((-0.033856)+(pz*pz)+(((0.033856)*(cj7*cj7)))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x23=((0.184)*sj7);
IkReal x24=IKsin(j6);
IkReal x25=((1.0)*pz);
IkReal x26=((0.184)*cj7);
IkReal x27=IKcos(j6);
evalcond[0]=((((-1.0)*x23))+(((-1.0)*x24*x25)));
evalcond[1]=((0.07708)+x26+(((-1.0)*x25*x27)));
evalcond[2]=((0.0279146736)+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x27)));
evalcond[3]=((((-0.07708)*x24))+(((-1.0)*x23*x27))+(((-1.0)*x24*x26)));
evalcond[4]=((((-1.0)*x25))+(((0.07708)*x27))+((x26*x27))+(((-1.0)*x23*x24)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x29=IKPowWithIntegerCheck(pz,-1);
if(!x29.valid){
continue;
}
IkReal x28=x29.value;
if( IKabs(((-0.184)*sj7*x28)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x28*(((0.07708)+(((0.184)*cj7)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.184)*sj7*x28))+IKsqr((x28*(((0.07708)+(((0.184)*cj7))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-0.184)*sj7*x28), (x28*(((0.07708)+(((0.184)*cj7))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x30=((0.184)*sj7);
IkReal x31=IKsin(j6);
IkReal x32=((1.0)*pz);
IkReal x33=((0.184)*cj7);
IkReal x34=IKcos(j6);
evalcond[0]=((((-1.0)*x30))+(((-1.0)*x31*x32)));
evalcond[1]=((0.07708)+x33+(((-1.0)*x32*x34)));
evalcond[2]=((0.0279146736)+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x34)));
evalcond[3]=((((-0.07708)*x31))+(((-1.0)*x30*x34))+(((-1.0)*x31*x33)));
evalcond[4]=((((-1.0)*x32))+(((0.07708)*x34))+((x33*x34))+(((-1.0)*x30*x31)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j6array[2], cj6array[2], sj6array[2];
bool j6valid[2]={false};
_nj6 = 2;
IkReal x35=((0.07708)+(((0.184)*cj7)));
CheckValue<IkReal> x38 = IKatan2WithCheck(IkReal(x35),IkReal(((-1.0)*(((0.184)*sj7)))),IKFAST_ATAN2_MAGTHRESH);
if(!x38.valid){
continue;
}
IkReal x36=((-1.0)*(x38.value));
if((((x35*x35)+(((0.033856)*(sj7*sj7))))) < -0.00001)
continue;
CheckValue<IkReal> x39=IKPowWithIntegerCheck(IKabs(IKsqrt(((x35*x35)+(((0.033856)*(sj7*sj7)))))),-1);
if(!x39.valid){
continue;
}
if( ((pz*(x39.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x39.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x37=IKasin((pz*(x39.value)));
j6array[0]=(x36+x37);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
j6array[1]=((3.14159265358979)+x36+(((-1.0)*x37)));
sj6array[1]=IKsin(j6array[1]);
cj6array[1]=IKcos(j6array[1]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
if( j6array[1] > IKPI )
{
    j6array[1]-=IK2PI;
}
else if( j6array[1] < -IKPI )
{    j6array[1]+=IK2PI;
}
j6valid[1] = true;
for(int ij6 = 0; ij6 < 2; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 2; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IkReal j5eval[3];
IkReal x40=(((cj6*(px*px)))+((cj6*(py*py))));
IkReal x41=((23.0)*sj7);
IkReal x42=((125.0)*pz*sj6);
j5eval[0]=x40;
j5eval[1]=IKsign(x40);
j5eval[2]=((IKabs((((px*x41))+((px*x42)))))+(IKabs((((py*x41))+((py*x42))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x43=(((sj6*(px*px)))+((sj6*(py*py))));
IkReal x44=((4600.0)*cj7);
IkReal x45=((25000.0)*cj6*pz);
j5eval[0]=x43;
j5eval[1]=IKsign(x43);
j5eval[2]=((IKabs(((((1927.0)*px))+((px*x44))+(((-1.0)*px*x45)))))+(IKabs(((((1927.0)*py))+((py*x44))+(((-1.0)*py*x45))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x46=((px*px)+(py*py));
IkReal x47=((1927.0)*sj6);
IkReal x48=((4600.0)*cj6*sj7);
IkReal x49=((4600.0)*cj7*sj6);
j5eval[0]=x46;
j5eval[1]=IKsign(x46);
j5eval[2]=((IKabs((((px*x47))+((px*x48))+((px*x49)))))+(IKabs((((py*x47))+((py*x48))+((py*x49))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j6))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[4];
sj6=0;
cj6=1.0;
j6=0;
IkReal x50=px*px;
IkReal x51=py*py;
j5eval[0]=(x50+x51);
j5eval[1]=IKsign(((((125.0)*x50))+(((125.0)*x51))));
j5eval[2]=529.0;
j5eval[3]=sj7;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  || IKabs(j5eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j7))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj6=0;
cj6=1.0;
j6=0;
sj7=0;
cj7=1.0;
j7=0;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[4], cj5array[4], sj5array[4];
bool j5valid[4]={false};
_nj5 = 4;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=1.5707963267949;
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
j5array[2]=3.14159265358979;
sj5array[2]=IKsin(j5array[2]);
cj5array[2]=IKcos(j5array[2]);
j5array[3]=-1.5707963267949;
sj5array[3]=IKsin(j5array[3]);
cj5array[3]=IKcos(j5array[3]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
if( j5array[2] > IKPI )
{
    j5array[2]-=IK2PI;
}
else if( j5array[2] < -IKPI )
{    j5array[2]+=IK2PI;
}
j5valid[2] = true;
if( j5array[3] > IKPI )
{
    j5array[3]-=IK2PI;
}
else if( j5array[3] < -IKPI )
{    j5array[3]+=IK2PI;
}
j5valid[3] = true;
for(int ij5 = 0; ij5 < 4; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 4; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x53 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x53.valid){
continue;
}
IkReal x52=((-1.0)*(x53.value));
j5array[0]=x52;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x52);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j7)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj6=0;
cj6=1.0;
j6=0;
sj7=0;
cj7=-1.0;
j7=3.14159265358979;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[4], cj5array[4], sj5array[4];
bool j5valid[4]={false};
_nj5 = 4;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=1.5707963267949;
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
j5array[2]=3.14159265358979;
sj5array[2]=IKsin(j5array[2]);
cj5array[2]=IKcos(j5array[2]);
j5array[3]=-1.5707963267949;
sj5array[3]=IKsin(j5array[3]);
cj5array[3]=IKcos(j5array[3]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
if( j5array[2] > IKPI )
{
    j5array[2]-=IK2PI;
}
else if( j5array[2] < -IKPI )
{    j5array[2]+=IK2PI;
}
j5valid[2] = true;
if( j5array[3] > IKPI )
{
    j5array[3]-=IK2PI;
}
else if( j5array[3] < -IKPI )
{    j5array[3]+=IK2PI;
}
j5valid[3] = true;
for(int ij5 = 0; ij5 < 4; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 4; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x55 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x55.valid){
continue;
}
IkReal x54=((-1.0)*(x55.value));
j5array[0]=x54;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x54);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x56=((23.0)*sj7);
CheckValue<IkReal> x57=IKPowWithIntegerCheck(IKsign(((((125.0)*(px*px)))+(((125.0)*(py*py))))),-1);
if(!x57.valid){
continue;
}
CheckValue<IkReal> x58 = IKatan2WithCheck(IkReal(((-1.0)*py*x56)),IkReal(((-1.0)*px*x56)),IKFAST_ATAN2_MAGTHRESH);
if(!x58.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x57.value)))+(x58.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x59=IKcos(j5);
IkReal x60=IKsin(j5);
IkReal x61=((1.0)*px);
evalcond[0]=(((py*x59))+(((-1.0)*x60*x61)));
evalcond[1]=((((-1.0)*(0.184)*sj7))+(((-1.0)*x59*x61))+(((-1.0)*py*x60)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[4];
sj6=0;
cj6=-1.0;
j6=3.14159265358979;
IkReal x62=px*px;
IkReal x63=py*py;
j5eval[0]=(x62+x63);
j5eval[1]=IKsign(((((125.0)*x62))+(((125.0)*x63))));
j5eval[2]=529.0;
j5eval[3]=sj7;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  || IKabs(j5eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j7))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj6=0;
cj6=-1.0;
j6=3.14159265358979;
sj7=0;
cj7=1.0;
j7=0;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[4], cj5array[4], sj5array[4];
bool j5valid[4]={false};
_nj5 = 4;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=1.5707963267949;
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
j5array[2]=3.14159265358979;
sj5array[2]=IKsin(j5array[2]);
cj5array[2]=IKcos(j5array[2]);
j5array[3]=-1.5707963267949;
sj5array[3]=IKsin(j5array[3]);
cj5array[3]=IKcos(j5array[3]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
if( j5array[2] > IKPI )
{
    j5array[2]-=IK2PI;
}
else if( j5array[2] < -IKPI )
{    j5array[2]+=IK2PI;
}
j5valid[2] = true;
if( j5array[3] > IKPI )
{
    j5array[3]-=IK2PI;
}
else if( j5array[3] < -IKPI )
{    j5array[3]+=IK2PI;
}
j5valid[3] = true;
for(int ij5 = 0; ij5 < 4; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 4; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x65 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x65.valid){
continue;
}
IkReal x64=((-1.0)*(((1.0)*(x65.value))));
j5array[0]=x64;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x64);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=(((py*(IKcos(j5))))+(((-1.0)*(1.0)*px*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j7)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj6=0;
cj6=-1.0;
j6=3.14159265358979;
sj7=0;
cj7=-1.0;
j7=3.14159265358979;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[4], cj5array[4], sj5array[4];
bool j5valid[4]={false};
_nj5 = 4;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=1.5707963267949;
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
j5array[2]=3.14159265358979;
sj5array[2]=IKsin(j5array[2]);
cj5array[2]=IKcos(j5array[2]);
j5array[3]=-1.5707963267949;
sj5array[3]=IKsin(j5array[3]);
cj5array[3]=IKcos(j5array[3]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
if( j5array[2] > IKPI )
{
    j5array[2]-=IK2PI;
}
else if( j5array[2] < -IKPI )
{    j5array[2]+=IK2PI;
}
j5valid[2] = true;
if( j5array[3] > IKPI )
{
    j5array[3]-=IK2PI;
}
else if( j5array[3] < -IKPI )
{    j5array[3]+=IK2PI;
}
j5valid[3] = true;
for(int ij5 = 0; ij5 < 4; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 4; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x67 = IKatan2WithCheck(IkReal(px),IkReal(py),IKFAST_ATAN2_MAGTHRESH);
if(!x67.valid){
continue;
}
IkReal x66=((-1.0)*(((1.0)*(x67.value))));
j5array[0]=x66;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x66);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=(((py*(IKcos(j5))))+(((-1.0)*(1.0)*px*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x68=((23.0)*sj7);
CheckValue<IkReal> x69=IKPowWithIntegerCheck(IKsign(((((125.0)*(px*px)))+(((125.0)*(py*py))))),-1);
if(!x69.valid){
continue;
}
CheckValue<IkReal> x70 = IKatan2WithCheck(IkReal((py*x68)),IkReal((px*x68)),IKFAST_ATAN2_MAGTHRESH);
if(!x70.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x69.value)))+(x70.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[2];
IkReal x71=IKcos(j5);
IkReal x72=IKsin(j5);
evalcond[0]=(((py*x71))+(((-1.0)*px*x72)));
evalcond[1]=(((px*x71))+((py*x72))+(((-1.0)*(0.184)*sj7)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
sj6=1.0;
cj6=0;
j6=1.5707963267949;
IkReal x73=((px*px)+(py*py));
IkReal x74=((4600.0)*cj7);
j5eval[0]=x73;
j5eval[1]=IKsign(x73);
j5eval[2]=((IKabs(((((1927.0)*px))+((px*x74)))))+(IKabs(((((1927.0)*py))+((py*x74))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
sj6=1.0;
cj6=0;
j6=1.5707963267949;
IkReal x75=px*px;
IkReal x76=py*py;
IkReal x77=((625000000.0)*px);
IkReal x78=pz*pz;
IkReal x79=((625000000.0)*py);
j5eval[0]=(x75+x76);
j5eval[1]=IKsign(((((1927.0)*x75))+(((1927.0)*x76))));
j5eval[2]=((IKabs(((((625000000.0)*(px*px*px)))+((x76*x77))+((x77*x78))+(((-1.0)*(17446671.0)*px)))))+(IKabs(((((625000000.0)*(py*py*py)))+((x75*x79))+((x78*x79))+(((-1.0)*(17446671.0)*py))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x80=px*px;
IkReal x81=py*py;
IkReal x82=((12500.0)*py);
IkReal x83=pz*pz;
IkReal x84=((12500.0)*px);
CheckValue<IkReal> x85=IKPowWithIntegerCheck(IKsign(((((1927.0)*x80))+(((1927.0)*x81)))),-1);
if(!x85.valid){
continue;
}
CheckValue<IkReal> x86 = IKatan2WithCheck(IkReal(((((348.93342)*py))+(((-1.0)*(12500.0)*(py*py*py)))+(((-1.0)*x80*x82))+(((-1.0)*x82*x83)))),IkReal(((((348.93342)*px))+(((-1.0)*(12500.0)*(px*px*px)))+(((-1.0)*x81*x84))+(((-1.0)*x83*x84)))),IKFAST_ATAN2_MAGTHRESH);
if(!x86.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x85.value)))+(x86.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x87=IKcos(j5);
IkReal x88=IKsin(j5);
IkReal x89=(px*x87);
IkReal x90=(py*x88);
evalcond[0]=(((py*x87))+(((-1.0)*px*x88)));
evalcond[1]=((0.07708)+x89+x90+(((0.184)*cj7)));
evalcond[2]=((0.0279146736)+(((-0.15416)*x89))+(((-0.15416)*x90))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x91=((0.184)*cj7);
CheckValue<IkReal> x92=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x92.valid){
continue;
}
CheckValue<IkReal> x93 = IKatan2WithCheck(IkReal(((((-1.0)*(0.07708)*py))+(((-1.0)*py*x91)))),IkReal(((((-1.0)*(0.07708)*px))+(((-1.0)*px*x91)))),IKFAST_ATAN2_MAGTHRESH);
if(!x93.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x92.value)))+(x93.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x94=IKcos(j5);
IkReal x95=IKsin(j5);
IkReal x96=(px*x94);
IkReal x97=(py*x95);
evalcond[0]=(((py*x94))+(((-1.0)*px*x95)));
evalcond[1]=((0.07708)+x96+x97+(((0.184)*cj7)));
evalcond[2]=((0.0279146736)+(((-0.15416)*x96))+(((-0.15416)*x97))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
sj6=-1.0;
cj6=0;
j6=-1.5707963267949;
IkReal x98=((px*px)+(py*py));
IkReal x99=((4600.0)*cj7);
j5eval[0]=x98;
j5eval[1]=IKsign(x98);
j5eval[2]=((IKabs(((((1927.0)*px))+((px*x99)))))+(IKabs(((((1927.0)*py))+((py*x99))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
sj6=-1.0;
cj6=0;
j6=-1.5707963267949;
IkReal x100=px*px;
IkReal x101=py*py;
IkReal x102=((625000000.0)*px);
IkReal x103=pz*pz;
IkReal x104=((625000000.0)*py);
j5eval[0]=(x100+x101);
j5eval[1]=IKsign(((((1927.0)*x100))+(((1927.0)*x101))));
j5eval[2]=((IKabs(((((625000000.0)*(px*px*px)))+((x101*x102))+((x102*x103))+(((-1.0)*(17446671.0)*px)))))+(IKabs(((((625000000.0)*(py*py*py)))+((x100*x104))+((x103*x104))+(((-1.0)*(17446671.0)*py))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x105=px*px;
IkReal x106=py*py;
IkReal x107=((12500.0)*py);
IkReal x108=pz*pz;
IkReal x109=((12500.0)*px);
CheckValue<IkReal> x110=IKPowWithIntegerCheck(IKsign(((((1927.0)*x105))+(((1927.0)*x106)))),-1);
if(!x110.valid){
continue;
}
CheckValue<IkReal> x111 = IKatan2WithCheck(IkReal(((((12500.0)*(py*py*py)))+((x105*x107))+((x107*x108))+(((-1.0)*(348.93342)*py)))),IkReal(((((12500.0)*(px*px*px)))+((x106*x109))+((x108*x109))+(((-1.0)*(348.93342)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x111.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x110.value)))+(x111.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x112=IKcos(j5);
IkReal x113=IKsin(j5);
IkReal x114=((1.0)*px);
IkReal x115=(py*x113);
evalcond[0]=(((py*x112))+(((-1.0)*x113*x114)));
evalcond[1]=((0.07708)+(((0.184)*cj7))+(((-1.0)*x115))+(((-1.0)*x112*x114)));
evalcond[2]=((0.0279146736)+(((0.15416)*x115))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*px*x112)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x116=((0.184)*cj7);
CheckValue<IkReal> x117=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x117.valid){
continue;
}
CheckValue<IkReal> x118 = IKatan2WithCheck(IkReal(((((0.07708)*py))+((py*x116)))),IkReal(((((0.07708)*px))+((px*x116)))),IKFAST_ATAN2_MAGTHRESH);
if(!x118.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x117.value)))+(x118.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[3];
IkReal x119=IKcos(j5);
IkReal x120=IKsin(j5);
IkReal x121=((1.0)*px);
IkReal x122=(py*x120);
evalcond[0]=(((py*x119))+(((-1.0)*x120*x121)));
evalcond[1]=((0.07708)+(((0.184)*cj7))+(((-1.0)*x122))+(((-1.0)*x119*x121)));
evalcond[2]=((0.0279146736)+(((0.15416)*x122))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*px*x119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j7), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
pz=0;
j7=0;
sj7=0;
cj7=1.0;
pp=((px*px)+(py*py));
IkReal x123=(sj6*(px*px));
IkReal x124=(sj6*(py*py));
j5eval[0]=(x123+x124);
j5eval[1]=IKsign(((((25000.0)*x123))+(((25000.0)*x124))));
j5eval[2]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[4];
pz=0;
j7=0;
sj7=0;
cj7=1.0;
pp=((px*px)+(py*py));
IkReal x125=px*px;
IkReal x126=py*py;
j5eval[0]=(x125+x126);
j5eval[1]=IKsign(((((25000.0)*x125))+(((25000.0)*x126))));
j5eval[2]=42601729.0;
j5eval[3]=sj6;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  || IKabs(j5eval[3]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
pz=0;
j7=0;
sj7=0;
cj7=1.0;
pp=((px*px)+(py*py));
IkReal x127=px*px;
IkReal x128=(sj6*x127);
IkReal x129=py*py;
IkReal x130=(sj6*x129);
j5eval[0]=(x128+x130);
j5eval[1]=IKsign(((((1927.0)*x128))+(((1927.0)*x130))));
j5eval[2]=((IKabs(((((625000000.0)*(px*px*px)))+(((-1.0)*(17446671.0)*px))+(((625000000.0)*px*x129)))))+(IKabs(((((625000000.0)*(py*py*py)))+(((-1.0)*(17446671.0)*py))+(((625000000.0)*py*x127))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j6))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
pz=0;
j7=0;
sj7=0;
cj7=1.0;
pp=((px*px)+(py*py));
sj6=0;
cj6=1.0;
j6=0;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x132 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x132.valid){
continue;
}
IkReal x131=((-1.0)*(x132.value));
j5array[0]=x131;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x131);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
pz=0;
j7=0;
sj7=0;
cj7=1.0;
pp=((px*px)+(py*py));
sj6=0;
cj6=-1.0;
j6=3.14159265358979;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x134 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x134.valid){
continue;
}
IkReal x133=((-1.0)*(x134.value));
j5array[0]=x133;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x133);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x135=px*px;
IkReal x136=((1927.0)*sj6);
IkReal x137=py*py;
CheckValue<IkReal> x138=IKPowWithIntegerCheck(IKsign((((x135*x136))+((x136*x137)))),-1);
if(!x138.valid){
continue;
}
CheckValue<IkReal> x139 = IKatan2WithCheck(IkReal(((((348.93342)*py))+(((-1.0)*(12500.0)*(py*py*py)))+(((-12500.0)*py*x135)))),IkReal(((((348.93342)*px))+(((-1.0)*(12500.0)*(px*px*px)))+(((-12500.0)*px*x137)))),IKFAST_ATAN2_MAGTHRESH);
if(!x139.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x138.value)))+(x139.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x140=IKcos(j5);
IkReal x141=IKsin(j5);
IkReal x142=((1.0)*px);
IkReal x143=(px*sj6*x140);
IkReal x144=(py*x141);
IkReal x145=(sj6*x144);
evalcond[0]=(((py*x140))+(((-1.0)*x141*x142)));
evalcond[1]=((0.26108)+x143+x145);
evalcond[2]=((((-1.0)*x144))+(((-1.0)*(0.26108)*sj6))+(((-1.0)*x140*x142)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x143))+(((-0.15416)*x145))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x146=((6527.0)*sj6);
CheckValue<IkReal> x147=IKPowWithIntegerCheck(IKsign(((((25000.0)*(px*px)))+(((25000.0)*(py*py))))),-1);
if(!x147.valid){
continue;
}
CheckValue<IkReal> x148 = IKatan2WithCheck(IkReal(((-1.0)*py*x146)),IkReal(((-1.0)*px*x146)),IKFAST_ATAN2_MAGTHRESH);
if(!x148.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x147.value)))+(x148.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x149=IKcos(j5);
IkReal x150=IKsin(j5);
IkReal x151=((1.0)*px);
IkReal x152=(px*sj6*x149);
IkReal x153=(py*x150);
IkReal x154=(sj6*x153);
evalcond[0]=(((py*x149))+(((-1.0)*x150*x151)));
evalcond[1]=((0.26108)+x152+x154);
evalcond[2]=((((-1.0)*x153))+(((-1.0)*(0.26108)*sj6))+(((-1.0)*x149*x151)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x152))+(((-0.15416)*x154))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x155=((25000.0)*sj6);
CheckValue<IkReal> x156=IKPowWithIntegerCheck(IKsign((((x155*(px*px)))+((x155*(py*py))))),-1);
if(!x156.valid){
continue;
}
CheckValue<IkReal> x157 = IKatan2WithCheck(IkReal(((-1.0)*(((6527.0)*py)))),IkReal(((-1.0)*(((6527.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x157.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x156.value)))+(x157.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x158=IKcos(j5);
IkReal x159=IKsin(j5);
IkReal x160=((1.0)*px);
IkReal x161=(px*sj6*x158);
IkReal x162=(py*x159);
IkReal x163=(sj6*x162);
evalcond[0]=(((py*x158))+(((-1.0)*x159*x160)));
evalcond[1]=((0.26108)+x161+x163);
evalcond[2]=((((-1.0)*x162))+(((-1.0)*(0.26108)*sj6))+(((-1.0)*x158*x160)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x161))+(((-0.15416)*x163))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j7, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
pz=0;
j7=3.14159265358979;
sj7=0;
cj7=-1.0;
pp=((px*px)+(py*py));
IkReal x164=(sj6*(px*px));
IkReal x165=(sj6*(py*py));
j5eval[0]=(x164+x165);
j5eval[1]=IKsign(((((25000.0)*x164))+(((25000.0)*x165))));
j5eval[2]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[4];
pz=0;
j7=3.14159265358979;
sj7=0;
cj7=-1.0;
pp=((px*px)+(py*py));
IkReal x166=px*px;
IkReal x167=py*py;
j5eval[0]=(x166+x167);
j5eval[1]=IKsign(((((25000.0)*x166))+(((25000.0)*x167))));
j5eval[2]=7144929.0;
j5eval[3]=sj6;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  || IKabs(j5eval[3]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
pz=0;
j7=3.14159265358979;
sj7=0;
cj7=-1.0;
pp=((px*px)+(py*py));
IkReal x168=px*px;
IkReal x169=(sj6*x168);
IkReal x170=py*py;
IkReal x171=(sj6*x170);
j5eval[0]=(x169+x171);
j5eval[1]=IKsign(((((1927.0)*x169))+(((1927.0)*x171))));
j5eval[2]=((IKabs(((((625000000.0)*(px*px*px)))+(((-1.0)*(17446671.0)*px))+(((625000000.0)*px*x170)))))+(IKabs(((((625000000.0)*(py*py*py)))+(((-1.0)*(17446671.0)*py))+(((625000000.0)*py*x168))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j6))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
pz=0;
j7=3.14159265358979;
sj7=0;
cj7=-1.0;
pp=((px*px)+(py*py));
sj6=0;
cj6=1.0;
j6=0;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x173 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x173.valid){
continue;
}
IkReal x172=((-1.0)*(x173.value));
j5array[0]=x172;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x172);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
pz=0;
j7=3.14159265358979;
sj7=0;
cj7=-1.0;
pp=((px*px)+(py*py));
sj6=0;
cj6=-1.0;
j6=3.14159265358979;
j5eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x175 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x175.valid){
continue;
}
IkReal x174=((-1.0)*(x175.value));
j5array[0]=x174;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x174);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*px*(IKcos(j5))))+(((-1.0)*(1.0)*py*(IKsin(j5)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x176=px*px;
IkReal x177=((1927.0)*sj6);
IkReal x178=py*py;
CheckValue<IkReal> x179=IKPowWithIntegerCheck(IKsign((((x176*x177))+((x177*x178)))),-1);
if(!x179.valid){
continue;
}
CheckValue<IkReal> x180 = IKatan2WithCheck(IkReal(((((348.93342)*py))+(((-1.0)*(12500.0)*(py*py*py)))+(((-12500.0)*py*x176)))),IkReal(((((348.93342)*px))+(((-1.0)*(12500.0)*(px*px*px)))+(((-12500.0)*px*x178)))),IKFAST_ATAN2_MAGTHRESH);
if(!x180.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x179.value)))+(x180.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x181=IKcos(j5);
IkReal x182=IKsin(j5);
IkReal x183=((1.0)*px);
IkReal x184=(px*sj6*x181);
IkReal x185=(py*x182);
IkReal x186=(sj6*x185);
evalcond[0]=(((py*x181))+(((-1.0)*x182*x183)));
evalcond[1]=((-0.10692)+x184+x186);
evalcond[2]=((((0.10692)*sj6))+(((-1.0)*x185))+(((-1.0)*x181*x183)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x184))+(((-0.15416)*x186))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x187=((2673.0)*sj6);
CheckValue<IkReal> x188=IKPowWithIntegerCheck(IKsign(((((25000.0)*(px*px)))+(((25000.0)*(py*py))))),-1);
if(!x188.valid){
continue;
}
CheckValue<IkReal> x189 = IKatan2WithCheck(IkReal((py*x187)),IkReal((px*x187)),IKFAST_ATAN2_MAGTHRESH);
if(!x189.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x188.value)))+(x189.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x190=IKcos(j5);
IkReal x191=IKsin(j5);
IkReal x192=((1.0)*px);
IkReal x193=(px*sj6*x190);
IkReal x194=(py*x191);
IkReal x195=(sj6*x194);
evalcond[0]=(((py*x190))+(((-1.0)*x191*x192)));
evalcond[1]=((-0.10692)+x193+x195);
evalcond[2]=((((0.10692)*sj6))+(((-1.0)*x194))+(((-1.0)*x190*x192)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x193))+(((-0.15416)*x195))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x196=((25000.0)*sj6);
CheckValue<IkReal> x197=IKPowWithIntegerCheck(IKsign((((x196*(px*px)))+((x196*(py*py))))),-1);
if(!x197.valid){
continue;
}
CheckValue<IkReal> x198 = IKatan2WithCheck(IkReal(((2673.0)*py)),IkReal(((2673.0)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x198.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x197.value)))+(x198.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[4];
IkReal x199=IKcos(j5);
IkReal x200=IKsin(j5);
IkReal x201=((1.0)*px);
IkReal x202=(px*sj6*x199);
IkReal x203=(py*x200);
IkReal x204=(sj6*x203);
evalcond[0]=(((py*x199))+(((-1.0)*x200*x201)));
evalcond[1]=((-0.10692)+x202+x204);
evalcond[2]=((((0.10692)*sj6))+(((-1.0)*x203))+(((-1.0)*x199*x201)));
evalcond[3]=((0.0279146736)+(((-0.15416)*x202))+(((-0.15416)*x204))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x205=((0.07708)*sj6);
IkReal x206=((0.184)*cj6*sj7);
IkReal x207=((0.184)*cj7*sj6);
CheckValue<IkReal> x208=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x208.valid){
continue;
}
CheckValue<IkReal> x209 = IKatan2WithCheck(IkReal(((((-1.0)*py*x205))+(((-1.0)*py*x206))+(((-1.0)*py*x207)))),IkReal(((((-1.0)*px*x205))+(((-1.0)*px*x206))+(((-1.0)*px*x207)))),IKFAST_ATAN2_MAGTHRESH);
if(!x209.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x208.value)))+(x209.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x210=IKcos(j5);
IkReal x211=IKsin(j5);
IkReal x212=((1.0)*px);
IkReal x213=((0.184)*cj7);
IkReal x214=(cj6*pz);
IkReal x215=(px*sj6*x210);
IkReal x216=(py*x211);
IkReal x217=(sj6*x216);
IkReal x218=((0.184)*sj7);
IkReal x219=(x210*x212);
IkReal x220=((1.0)*x216);
evalcond[0]=(((py*x210))+(((-1.0)*x211*x212)));
evalcond[1]=((0.07708)+x213+x215+x217+(((-1.0)*x214)));
evalcond[2]=((((-1.0)*x218))+(((-1.0)*cj6*x219))+(((-1.0)*cj6*x220))+(((-1.0)*(1.0)*pz*sj6)));
evalcond[3]=((((-1.0)*x219))+(((-1.0)*x220))+(((-1.0)*(0.07708)*sj6))+(((-1.0)*cj6*x218))+(((-1.0)*sj6*x213)));
evalcond[4]=((0.0279146736)+(((0.15416)*x214))+(((-0.15416)*x215))+(((-0.15416)*x217))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x221=((0.184)*cj7);
IkReal x222=(cj6*pz);
CheckValue<IkReal> x223=IKPowWithIntegerCheck(IKsign((((sj6*(px*px)))+((sj6*(py*py))))),-1);
if(!x223.valid){
continue;
}
CheckValue<IkReal> x224 = IKatan2WithCheck(IkReal((((py*x222))+(((-1.0)*(0.07708)*py))+(((-1.0)*py*x221)))),IkReal((((px*x222))+(((-1.0)*(0.07708)*px))+(((-1.0)*px*x221)))),IKFAST_ATAN2_MAGTHRESH);
if(!x224.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x223.value)))+(x224.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x225=IKcos(j5);
IkReal x226=IKsin(j5);
IkReal x227=((1.0)*px);
IkReal x228=((0.184)*cj7);
IkReal x229=(cj6*pz);
IkReal x230=(px*sj6*x225);
IkReal x231=(py*x226);
IkReal x232=(sj6*x231);
IkReal x233=((0.184)*sj7);
IkReal x234=(x225*x227);
IkReal x235=((1.0)*x231);
evalcond[0]=(((py*x225))+(((-1.0)*x226*x227)));
evalcond[1]=((0.07708)+x228+x230+x232+(((-1.0)*x229)));
evalcond[2]=((((-1.0)*x233))+(((-1.0)*cj6*x234))+(((-1.0)*cj6*x235))+(((-1.0)*(1.0)*pz*sj6)));
evalcond[3]=((((-1.0)*x234))+(((-1.0)*x235))+(((-1.0)*(0.07708)*sj6))+(((-1.0)*cj6*x233))+(((-1.0)*sj6*x228)));
evalcond[4]=((0.0279146736)+(((0.15416)*x229))+(((-0.15416)*x230))+(((-0.15416)*x232))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x236=((0.184)*sj7);
IkReal x237=((1.0)*pz*sj6);
CheckValue<IkReal> x238=IKPowWithIntegerCheck(IKsign((((cj6*(px*px)))+((cj6*(py*py))))),-1);
if(!x238.valid){
continue;
}
CheckValue<IkReal> x239 = IKatan2WithCheck(IkReal(((((-1.0)*py*x236))+(((-1.0)*py*x237)))),IkReal(((((-1.0)*px*x236))+(((-1.0)*px*x237)))),IKFAST_ATAN2_MAGTHRESH);
if(!x239.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x238.value)))+(x239.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[5];
IkReal x240=IKcos(j5);
IkReal x241=IKsin(j5);
IkReal x242=((1.0)*px);
IkReal x243=((0.184)*cj7);
IkReal x244=(cj6*pz);
IkReal x245=(px*sj6*x240);
IkReal x246=(py*x241);
IkReal x247=(sj6*x246);
IkReal x248=((0.184)*sj7);
IkReal x249=(x240*x242);
IkReal x250=((1.0)*x246);
evalcond[0]=(((py*x240))+(((-1.0)*x241*x242)));
evalcond[1]=((0.07708)+x243+x245+x247+(((-1.0)*x244)));
evalcond[2]=((((-1.0)*x248))+(((-1.0)*cj6*x249))+(((-1.0)*cj6*x250))+(((-1.0)*(1.0)*pz*sj6)));
evalcond[3]=((((-1.0)*x249))+(((-1.0)*x250))+(((-1.0)*(0.07708)*sj6))+(((-1.0)*cj6*x248))+(((-1.0)*sj6*x243)));
evalcond[4]=((0.0279146736)+(((0.15416)*x244))+(((-0.15416)*x245))+(((-0.15416)*x247))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x252 = IKatan2WithCheck(IkReal(py),IkReal(((-1.0)*(((1.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x252.valid){
continue;
}
IkReal x251=((-1.0)*(x252.value));
j5array[0]=x251;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+x251);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x253=((2875.0)*pz);
IkReal x254=((2875.0)*cj5*px);
IkReal x255=((2875.0)*py*sj5);
j6eval[0]=((-1.40302164887976)+(((-1.0)*(1.0)*cj7)));
j6eval[1]=IKsign(((-621.833225)+(((-1.0)*(443.21)*cj7))));
j6eval[2]=((IKabs(((((1204.375)*pz))+((cj7*x253))+(((-1.0)*sj7*x254))+(((-1.0)*sj7*x255)))))+(IKabs((((cj7*x254))+((cj7*x255))+((sj7*x253))+(((1204.375)*cj5*px))+(((1204.375)*py*sj5))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x256=(cj5*px);
IkReal x257=(py*sj5);
IkReal x258=(pz*sj7);
IkReal x259=(cj5*cj7*px);
IkReal x260=(cj7*py*sj5);
IkReal x261=((125.0)*pz);
j6eval[0]=(x256+x257+(((2.38713025428127)*x259))+(((2.38713025428127)*x260))+(((-2.38713025428127)*x258)));
j6eval[1]=IKsign(((((23.0)*x259))+(((23.0)*x260))+(((9.635)*x256))+(((9.635)*x257))+(((-23.0)*x258))));
j6eval[2]=((IKabs(((0.7426658)+(((3.54568)*cj7))+(((4.232)*(cj7*cj7)))+(((-1.0)*(125.0)*(pz*pz))))))+(IKabs((((x256*x261))+((x257*x261))+(((-1.0)*(1.77284)*sj7))+(((-1.0)*(4.232)*cj7*sj7))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x262=py*py;
IkReal x263=(py*sj5);
IkReal x264=cj5*cj5;
IkReal x265=((((-1.0)*x262))+((x262*x264))+(((-1.0)*(1.0)*(pz*pz)))+(((-1.0)*x264*(px*px)))+(((-2.0)*cj5*px*x263)));
IkReal x266=((0.184)*pz);
IkReal x267=((0.184)*cj5*px);
IkReal x268=((0.184)*py*sj5);
j6eval[0]=x265;
j6eval[1]=IKsign(x265);
j6eval[2]=((IKabs(((((0.07708)*pz))+((cj7*x266))+(((-1.0)*sj7*x267))+(((-1.0)*sj7*x268)))))+(IKabs(((((0.07708)*x263))+((cj7*x267))+((cj7*x268))+((sj7*x266))+(((0.07708)*cj5*px))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j6]

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x269=py*py;
IkReal x270=(py*sj5);
IkReal x271=cj5*cj5;
IkReal x272=((0.184)*pz);
IkReal x273=((0.184)*cj5*px);
IkReal x274=((0.184)*py*sj5);
CheckValue<IkReal> x275=IKPowWithIntegerCheck(IKsign(((((-1.0)*x269))+((x269*x271))+(((-1.0)*(1.0)*(pz*pz)))+(((-1.0)*x271*(px*px)))+(((-2.0)*cj5*px*x270)))),-1);
if(!x275.valid){
continue;
}
CheckValue<IkReal> x276 = IKatan2WithCheck(IkReal(((((0.07708)*x270))+((cj7*x273))+((cj7*x274))+((sj7*x272))+(((0.07708)*cj5*px)))),IkReal((((sj7*x273))+((sj7*x274))+(((-1.0)*(0.07708)*pz))+(((-1.0)*cj7*x272)))),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x275.value)))+(x276.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x277=((1.0)*pz);
IkReal x278=IKcos(j6);
IkReal x279=((0.184)*cj7);
IkReal x280=IKsin(j6);
IkReal x281=((0.184)*sj7);
IkReal x282=(cj5*px);
IkReal x283=(x280*x282);
IkReal x284=(py*sj5);
IkReal x285=(x280*x284);
IkReal x286=((1.0)*x282);
IkReal x287=((1.0)*x284);
evalcond[0]=((((-1.0)*x277))+(((0.07708)*x278))+((x278*x279))+(((-1.0)*x280*x281)));
evalcond[1]=((0.07708)+x279+x283+x285+(((-1.0)*x277*x278)));
evalcond[2]=((((-1.0)*x281))+(((-1.0)*x277*x280))+(((-1.0)*x278*x286))+(((-1.0)*x278*x287)));
evalcond[3]=((((-1.0)*x286))+(((-1.0)*x287))+(((-0.07708)*x280))+(((-1.0)*x278*x281))+(((-1.0)*x279*x280)));
evalcond[4]=((0.0279146736)+(((-0.15416)*x283))+(((-0.15416)*x285))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x278)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x288=(cj5*px);
IkReal x289=(py*sj5);
IkReal x290=((23.0)*cj7);
IkReal x291=((125.0)*pz);
CheckValue<IkReal> x292=IKPowWithIntegerCheck(IKsign(((((9.635)*x288))+(((9.635)*x289))+((x288*x290))+((x289*x290))+(((-1.0)*(23.0)*pz*sj7)))),-1);
if(!x292.valid){
continue;
}
CheckValue<IkReal> x293 = IKatan2WithCheck(IkReal(((-0.7426658)+(((125.0)*(pz*pz)))+(((-1.0)*(3.54568)*cj7))+(((-1.0)*(4.232)*(cj7*cj7))))),IkReal((((x288*x291))+((x289*x291))+(((-1.0)*(1.77284)*sj7))+(((-1.0)*(4.232)*cj7*sj7)))),IKFAST_ATAN2_MAGTHRESH);
if(!x293.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x292.value)))+(x293.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x294=((1.0)*pz);
IkReal x295=IKcos(j6);
IkReal x296=((0.184)*cj7);
IkReal x297=IKsin(j6);
IkReal x298=((0.184)*sj7);
IkReal x299=(cj5*px);
IkReal x300=(x297*x299);
IkReal x301=(py*sj5);
IkReal x302=(x297*x301);
IkReal x303=((1.0)*x299);
IkReal x304=((1.0)*x301);
evalcond[0]=((((-1.0)*x294))+(((0.07708)*x295))+((x295*x296))+(((-1.0)*x297*x298)));
evalcond[1]=((0.07708)+x296+x300+x302+(((-1.0)*x294*x295)));
evalcond[2]=((((-1.0)*x298))+(((-1.0)*x294*x297))+(((-1.0)*x295*x303))+(((-1.0)*x295*x304)));
evalcond[3]=((((-1.0)*x303))+(((-1.0)*x304))+(((-0.07708)*x297))+(((-1.0)*x295*x298))+(((-1.0)*x296*x297)));
evalcond[4]=((0.0279146736)+(((-0.15416)*x300))+(((-0.15416)*x302))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x305=((2875.0)*pz);
IkReal x306=((2875.0)*cj5*px);
IkReal x307=((2875.0)*py*sj5);
CheckValue<IkReal> x308=IKPowWithIntegerCheck(IKsign(((-621.833225)+(((-1.0)*(443.21)*cj7)))),-1);
if(!x308.valid){
continue;
}
CheckValue<IkReal> x309 = IKatan2WithCheck(IkReal((((cj7*x306))+((cj7*x307))+((sj7*x305))+(((1204.375)*cj5*px))+(((1204.375)*py*sj5)))),IkReal((((sj7*x306))+((sj7*x307))+(((-1.0)*(1204.375)*pz))+(((-1.0)*cj7*x305)))),IKFAST_ATAN2_MAGTHRESH);
if(!x309.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x308.value)))+(x309.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[5];
IkReal x310=((1.0)*pz);
IkReal x311=IKcos(j6);
IkReal x312=((0.184)*cj7);
IkReal x313=IKsin(j6);
IkReal x314=((0.184)*sj7);
IkReal x315=(cj5*px);
IkReal x316=(x313*x315);
IkReal x317=(py*sj5);
IkReal x318=(x313*x317);
IkReal x319=((1.0)*x315);
IkReal x320=((1.0)*x317);
evalcond[0]=((((-1.0)*x310))+(((0.07708)*x311))+((x311*x312))+(((-1.0)*x313*x314)));
evalcond[1]=((0.07708)+x312+x316+x318+(((-1.0)*x310*x311)));
evalcond[2]=((((-1.0)*x314))+(((-1.0)*x310*x313))+(((-1.0)*x311*x319))+(((-1.0)*x311*x320)));
evalcond[3]=((((-1.0)*x319))+(((-1.0)*x320))+(((-0.07708)*x313))+(((-1.0)*x311*x314))+(((-1.0)*x312*x313)));
evalcond[4]=((0.0279146736)+(((-0.15416)*x316))+(((-0.15416)*x318))+(((-1.0)*(1.0)*(px*px)))+(((-1.0)*(1.0)*(py*py)))+(((-1.0)*(1.0)*(pz*pz)))+(((0.15416)*pz*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(3);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j6;
vinfos[1].indices[0] = _ij6[0];
vinfos[1].indices[1] = _ij6[1];
vinfos[1].maxsolutions = _nj6;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j7;
vinfos[2].indices[0] = _ij7[0];
vinfos[2].indices[1] = _ij7[1];
vinfos[2].maxsolutions = _nj7;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - qtrobot (61c8542a5622c16e6b17b25fc9dc3aed)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
